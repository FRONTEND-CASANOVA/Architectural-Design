<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="src/assets/casanova.css">
    <title>6.4 Application architectures</title>
    <link href="./src/output.css" rel="stylesheet">
</head>

<body>

    <header>
        <center>
            <h1><a href="homepage.html" class="chapter1">CHAPTER 6</a></h1>
            <h2>Architectural Design</h2>
            <button><a href="chapter_6-1.html" class="chapter">Chapter 6.1</a></button>
            <button><a href="6.2.html" class="chapter">Chapter 6.2</a></button>
            <button><a href="Chapter6_3.html" class="chapter">Chapter 6.3</a></button>
            <button><a href="Chapter6.4.html" class="chapter">Chapter 6.4</a></button>
        </center>
    </header>

    <section class="first">
        
        <h2 class="galaw">Application architectures </h2>
        <h3> By: Casanova, John Harry S.</h3> </p>

        <article class="taas">
            <img src="mouse (4).png" alt=""> <a class="Panot"> Application architectures </a> <br> </p>
            Application systems are intended to meet a business or organizational need. All business 
            have much in common—they need to hire people, issue invoices, keep 
            accounts, and so on. Businesses operating in the same sector use common sector             specific applications. Therefore, as well as general business functions, all phone 
            companies need systems to connect calls, manage their network, issue bills to 
            customers, etc. Consequently, the application systems used by these businesses also 
            have much in common. </p>
            These commonalities have led to the development of software architectures 
            that describe the structure and organization of particular types of software sys 
            tems. Application architectures encapsulate the principal characteristics of a 
            class of systems. For example, in real-time systems, there might be generic archi 
            tectural models of different system types, such as data collection systems or 
            monitoring systems. Although instances of these systems differ in detail, the 
            common architectural structure can be reused when developing new systems of 
            the same type. </p>
            The application architecture may be re-implemented when developing new 
            systems but, for many business systems, application reuse is possible without re-
            implementation. We see this in the growth of Enterprise Resource Planning (ERP) 
            systems from companies such as SAP and Oracle, and vertical software packages 
            (COTS) for specialized applications in different areas of business. In these systems, 
            a generic system is configured and adapted to create a specific business application. </a>

        </article> <br>

<<<<<<< HEAD
        <article class="taas1">
            <img src="mouse (4).png" alt=""> <a> Application architectures </a> <br> </p>
=======
        <article>
            <img src="src/assets/img/mouse (2).png" alt=""> <a> Application architectures </a> <br> </p>
>>>>>>> 92b884f7d5fa7b323025e16b36dec10a5a23ffbb
            There are several examples of application architectures on the book’s website. These include descriptions of
            <br>
            batch data-processing systems, resource allocation systems, and event-based editing systems. <br> </p>

            <a href="http://www.SoftwareEngineering-9.com/Web/Architecture/AppArch/" class="link1">
                <b>http://www.SoftwareEngineering-9.com/Web/Architecture/AppArch/</b></a> </p>

        </article>

        <article class="second">
            For example, a system for supply chain management can be adapted for different 
            types of suppliers, goods, and contractual arrangements. <br>
            As a software designer, you can use models of application architectures in a num 
            ber of ways:  </p>

            1. As a starting point for the architectural design process If you are unfamiliar with 
            the type of application that you are developing, you can base your initial design 
            on a generic application architecture. Of course, this will have to be specialized 
            for the specific system being developed, but it is a good starting point for design. </p>
            2. As a design checklist If you have developed an architectural design for an appli
            cation system, you can compare this with the generic application architecture. 
            You can check that your design is consistent with the generic architecture. </p>
            3. As a way of organizing the work of the development team The application archi 
            tectures identify stable structural features of the system architectures and in
            many cases, it is possible to develop these in parallel. You can assign work to 
            group members to implement different components within the architecture. </p>
            4. As a means of assessing components for reuse If you have components you 
            might be able to reuse, you can compare these with the generic structures to see 
            whether there are comparable components in the application architecture. </p>
            5. As a vocabulary for talking about types of applications If you are discussing a spe 
            cific application or trying to compare applications of the same types, then you can 
            use the concepts identified in the generic architecture to talk about the applications. </p>

            There are many types of application system and, in some cases, they may seem to 
            be very different. However, many of these superficially dissimilar applications actu 
            ally have much in common, and thus can be represented by a single abstract applica 
            tion architecture. We illustrate this here by describing the following architectures of 
            two types of application:  </p>
            1. Transaction processing applications Transaction processing applications are 
            database-centered applications that process user requests for information and 
            update the information in a database. These are the most common type of inter 
            active business systems. They are organized in such a way that user actions can’t 
            interfere with each other and the integrity of the database is maintained. This </p>

<<<<<<< HEAD
            <img src="ggg.jpg" alt="" class="picture"> <br>
=======
            <img src="src/assets/img/ggg.jpg" alt=""> <br>
>>>>>>> 92b884f7d5fa7b323025e16b36dec10a5a23ffbb

            class of system includes interactive banking systems, e-commerce systems, 
            information systems, and booking systems. </p>
            2. Language processing systems Language processing systems are systems in
            which the user’s intentions are expressed in a formal language (such as Java).
            The language processing system processes this language into an internal format 
            and then interprets this internal representation. The best-known language pro 
            cessing systems are compilers, which translate high-level language programs 
            into machine code. However, language processing systems are also used to 
            interpret command languages for databases and information systems, and 
            markup languages such as XML (Harold and Means, 2002; Hunter et al., 2007). 
            We have chosen these particular types of system because a large number of web 
            based business systems are transaction-processing systems, and all software devel 
            opment relies on language processing systems. </p>

        </article>
        
    </section>




    <section class="second">
        <div id="6.4.1 Transaction processing systems"></div>
        <h2>6.4.1 Transaction processing systems</h2>

        <article>
            Transaction processing (TP) systems are designed to process user requests for infor 
            mation from a database, or requests to update a database (Lewis et al., 2003).
            Technically, a database transaction is sequence of operations that is treated as a sin 
            gle unit (an atomic unit). All of the operations in a transaction have to be completed 
            before the database changes are made permanent. This ensures that failure of opera 
            tions within the transaction does not lead to inconsistencies in the database. 
            From a user perspective, a transaction is any coherent sequence of operations that 
            satisfies a goal, such as ‘find the times of flights from London to Paris’. If the user 
            transaction does not require the database to be changed then it may not be necessary 
            to package this as a technical database transaction. <br>
            An example of a transaction is a customer request to withdraw money from a bank 
            account using an ATM. This involves getting details of the customer’s account, check 
            ing the balance, modifying the balance by the amount withdrawn, and sending com 
            mands to the ATM to deliver the cash. Until all of these steps have been completed, the 
            transaction is incomplete and the customer accounts database is not changed. <br>
            Transaction processing systems are usually interactive systems in which users 
            make asynchronous requests for service. Figure 6.14 illustrates the conceptual ar 
            chitectural structure of TP applications. First a user makes a request to the system 
            through an I/O processing component. The request is processed by some application 
            specific logic. A transaction is created and passed to a transaction manager, which is 
            usually embedded in the database management system. After the transaction manager <br>
<<<<<<< HEAD
            <img src="hhh.jpg" alt="" class="picture"> <br>
=======
            <img src="src/assets/img/hhh.jpg" alt=""> <br>
>>>>>>> 92b884f7d5fa7b323025e16b36dec10a5a23ffbb

            has ensured that the transaction is properly completed, it signals to the application 
            that processing has finished. <br>
            Transaction processing systems may be organized as a ‘pipe and filter’ architec 
            ture with system components responsible for input, processing, and output. For 
            example, consider a banking system that allows customers to query their accounts 
            and withdraw cash from an ATM. The system is composed of two cooperating soft 
            ware components—the ATM software and the account processing software in the 
            bank’s database server. The input and output components are implemented as soft 
            ware in the ATM and the processing component is part of the bank’s database server. <br>
            Figure 6.15 shows the architecture of this system, illustrating the functions of the 
            input, process, and output components. <br>

        </article>
        </div>
    </section>
    <section class="third">
        <div id="6.4.2 Information systems">
        <h2>6.4.2 Information systems</h2>

        <article>
            All systems that involve interaction with a shared database can be considered to be 
            transaction-based information systems. An information system allows controlled 
            access to a large base of information, such as a library catalog, a flight timetable, or 
            the records of patients in a hospital. Increasingly, information systems are web-based 
            systems that are accessed through a web browser. <br>
            Figure 6.16 a very general model of an information system. The system is mod 
            eled using a layered approach (discussed in Section 6.3) where the top layer supports 
            the user interface and the bottom layer is the system database. The user communica 
            tions layer handles all input and output from the user interface, and the information 
            retrieval layer includes application-specific logic for accessing and updating the 
            database. As we shall see later, the layers in this model can map directly onto servers
            in an Internet-based system. <br>
<<<<<<< HEAD
            As an example of an instantiation of this layered model, Figure 6.17 shows the 
            architecture of the MHC-PMS. Recall that this system maintains and manages details 
            of patients who are consulting specialist doctors about mental health problems. We have  </p>
            <img src="iii.jpg" alt="" class="picture"> <br>
            added detail to each layer in the model by identifying the components that support 
=======
            As an example of an instantiation of this layered model, Figure 6.17 shows the <br>
            architecture of the MHC-PMS. Recall that this system maintains and manages details <br>
            of patients who are consulting specialist doctors about mental health problems. We have <br> </p>
            <img src="src/assets/img/iii.jpg" alt=""> <br>
            added detail to each layer in the model by identifying the components that support <br>
>>>>>>> 92b884f7d5fa7b323025e16b36dec10a5a23ffbb
            user communications and information retrieval and access: </p>
            1. The top layer is responsible for implementing the user interface. In this case, the 
            UI has been implemented using a web browser. </p>
            2. The second layer provides the user interface functionality that is delivered 
            through the web browser. It includes components to allow users to log in to the 
            system and checking components that ensure that the operations they use are 
            allowed by their role. This layer includes form and menu management compo 
            nents that present information to users, and data validation components that 
            check information consistency. </p>
            3. The third layer implements the functionality of the system and provides compo 
            nents that implement system security, patient information creation and updating, 
            import and export of patient data from other databases, and report generators 
            that create management reports. </p>

<<<<<<< HEAD
            <img src="bbb.jpg" alt="" class="picture"> </p>
=======
            <img src="src/assets/img/bbb.jpg" alt=""> </p>
>>>>>>> 92b884f7d5fa7b323025e16b36dec10a5a23ffbb

            4. Finally, the lowest layer, which is built using a commercial database manage 
            ment system, provides transaction management and persistent data storage. </p>
            Information and resource management systems are now usually web-based systems 
            where the user interfaces are implemented using a web browser. For example, 
            e-commerce systems are Internet-based resource management systems that accept elec 
            tronic orders for goods or services and then arrange delivery of these goods or services 
            to the customer. In an e-commerce system, the application-specific layer includes addi 
            tional functionality supporting a ‘shopping cart’ in which users can place a number of 
            items in separate transactions, then pay for them all together in a single transaction. <br>
            The organization of servers in these systems usually reflects the four-layer 
            generic model presented in Figure 6.16. These systems are often implemented as 
            multi-tier client server/architectures, as discussed in Chapter 18:  </p>
            1. The web server is responsible for all user communications, with the user inter 
            face implemented using a web browser; </p>
            2. The application server is responsible for implementing application-specific 
            logic as well as information storage and retrieval requests; </p>
            3. The database server moves information to and from the database and handles 
            transaction management. </p>
            Using multiple servers allows high throughput and makes it possible to handle 
            hundreds of transactions per minute. As demand increases, servers can be added at 
            each level to cope with the extra processing involved. </p>

        </article>
        </div>
    </section>

    <section class="fourth">
        <div id="6.4.3 Language processing systems">
        <h2>6.4.3 Language processing systems</h2>

        <article>
            Language processing systems translate a natural or artificial language into another 
            representation of that language and, for programming languages, may also execute 
            the resulting code. In software engineering, compilers translate an artificial program 
            ming language into machine code. Other language-processing systems may translate 
            an XML data description into commands to query a database or to an alternative 
            XML representation. Natural language processing systems may translate one natural 
            language to another e.g., French to Norwegian. <br>
            A possible architecture for a language processing system for a programming lan 
            guage is illustrated in Figure 6.18. The source language instructions define the pro 
            gram to be executed and a translator converts these into instructions for an abstract 
            machine. These instructions are then interpreted by another component that fetches 
            the instructions for execution and executes them using (if necessary) data from the
            environment. The output of the process is the result of interpreting the instructions 
            on the input data. <br>

<<<<<<< HEAD
            <img src="lll.jpg" alt="" class="picture"> </p>
=======
            <img src="src/assets/img/lll.jpg" alt=""> </p>
>>>>>>> 92b884f7d5fa7b323025e16b36dec10a5a23ffbb

            <img src="src/assets/img/mouse (2).png" alt=""> <a> References architectures </a> <br> </p>

            Reference architectures capture important features of system architectures in a domain. Essentially,
            they include everything that might be in an application architecture although, in reality, it is very unlikely that
            any individual application would include all the features shown in a reference architecture. The main purpose of reference
            architectures is to evaluate and compare design proposals, and to educate people about architectural
            characteristics in that domain. </p>

            <a href="http://www.SoftwareEngineering-9.com/Web/Architecture/RefArch.html" class="link1">
                <b>http://www.SoftwareEngineering-9.com/Web/Architecture/RefArch.html</b></a> </p>

            5. A semantic analyzer that uses information from the syntax tree and the symbol 
            table to check the semantic correctness of the input language text. </p>
            6. A code generator that ‘walks’ the syntax tree and generates abstract machine code. </p>
            Other components might also be included which analyze and transform the syn 
            tax tree to improve efficiency and remove redundancy from the generated machine 
            code. In other types of language processing system, such as a natural language trans 
            lator, there will be additional components such as a dictionary, and the generated 
            code is actually the input text translated into another language. <br>
            There are alternative architectural patterns that may be used in a language pro 
            cessing system (Garlan and Shaw, 1993). Compilers can be implemented using a 
            composite of a repository and a pipe and filter model. In a compiler architecture, the 
            symbol table is a repository for shared data. The phases of lexical, syntactic, and 
            semantic analysis are organized sequentially, as shown in Figure 6.19, and commu 
            nicate through the shared symbol table. <br>
            This pipe and filter model of language compilation is effective in batch environ 
            ments where programs are compiled and executed without user interaction; for 
            example, in the translation of one XML document to another. It is less effective 
            when a compiler is integrated with other language processing tools such as a struc 
            tured editing system, an interactive debugger or a program prettyprinter. In this 
            situation, changes from one component need to be reflected immediately in other 
            components. It is better, therefore, to organize the system around a repository, as 
            shown in Figure 6.20. <br>
            This figure illustrates how a language processing system can be part of an integrated 
            set of programming support tools. In this example, the symbol table and syntax tree act 
            as a central information repository. Tools or tool fragments communicate through it. 
            Other information that is sometimes embedded in tools, such as the grammar definition 
            and the definition of the output format for the program, have been taken out of the tools 
            and put into the repository. Therefore, a syntax-directed editor can check that the syntax 
            of a program is correct as it is being typed and a prettyprinter can create listings of the 
            program in a format that is easy to read. <br>

<<<<<<< HEAD
            <img src="ppp.jpg" alt="" class="picture"> </p>

=======
            <img src="src/assets/img/ppp.jpg" alt=""> </p>
            
>>>>>>> 92b884f7d5fa7b323025e16b36dec10a5a23ffbb
        </article>

        </div>

    </section>

    <section class="keypoints">
        <article>
            <h2>Key Points</h2>
            <ul>
                <li>
                    A software architecture is a description of how a software system is organized. Properties of a <br>
                    system such as performance, security, and availability are influenced by the architecture used.
                </li> <br>
                <li>Architectural design decisions include decisions on the type of application, the distribution of
                    <br>
                    the system, the architectural styles to be used, and the ways in which the architecture should be
                    <br>
                    documented and evaluated.
                </li> <br>
                <li>Architectures may be documented from several different perspectives or views. Possible views 
                    include a conceptual view, a logical view, a process view, a development view, and a physical view.
                </li> <br>
                <li>Architectural patterns are a means of reusing knowledge about generic system architectures. 
                    They describe the architecture, explain when it may be used, and discuss its advantages and 
                    disadvantages. </li> <br>
                <li>Commonly used architectural patterns include Model-View-Controller, Layered Architecture, 
                    Repository, Client–server, and Pipe and Filter. </li> <br>
                <li>Generic models of application systems architectures help us understand the operation of 
                    applications, compare applications of the same type, validate application system designs, and
                    assess large-scale components for reuse. </li> <br>
                <li>Transaction processing systems are interactive systems that allow information in a database to 
                    be remotely accessed and modified by a number of users. Information systems and resource 
                    management systems are examples of transaction processing systems. </li> <br>
                <li>Language processing systems are used to translate texts from one language into another and 
                    to carry out the instructions specified in the input language. They include a translator and an 
                    abstract machine that executes the generated language. <br>
                </li>
            </ul>

        </article>

    </section>

    <section class="furtherreading">
        <h2>FURTHER READING</h2>

        <article>

            Software Architecture: Perspectives on an Emerging Discipline. This was the first book on 
            software architecture and has a good discussion on different architectural styles. (M. Shaw and 
            D. Garlan, Prentice-Hall, 1996.) </p>
            Software Architecture in Practice, 2nd ed. This is a practical discussion of software architectures that
            <br>
            does not oversell the benefits of architectural design. It provides a clear business rationale 
            explaining why architectures are important. (L. Bass, P. Clements and R. Kazman, Addison-Wesley, 
            2003.) </p>
            ‘The Golden Age of Software Architecture’This paper surveys the development of software 
            architecture from its beginnings in the 1980s through to its current usage. There is little technical 
            content but it is an interesting historical overview. (M. Shaw and P. Clements, IEEE Software, 
            21 (2), March–April 2006.) <a
                href="http://dx.doi.org/10.1109/MS.2006.58" class="link1">http://dx.doi.org/10.1109/MS.2006.58</a>.</p>
            Handbook of Software Architecture. This is a work in progress by Grady Booch, one of the 
            early evangelists for software architecture. He has been documenting the architectures of a range of 
            software systems so you can see reality rather than academic abstraction. Available on the Web and 
            intended to appear as a book. <a
                href="http://www.handbookofsoftwarearchitecture.com/" class="link1">http://www.handbookofsoftwarearchitecture.com/</a>.
            </p>

        </article>
    </section>

    <section class="exercises">
        <h2> EXERCISES </h2>

        <article>
            <ol start="6">
                <li>1 When describing a system, explain why you may have to design the system architecture 
                    before the requirements specification is complete. </li>
            </ol>
            <ol start="6">
                <li>2 You have been asked to prepare and deliver a presentation to a non-technical manager to 
                    justify the hiring of a system architect for a new project. Write a list of bullet points setting
                    out
                    the key points in your presentation. Naturally, you have to explain what is meant by system 
                    architecture.
            </ol>
            <ol start="6">
                <li>3 Explain why design conflicts might arise when designing an architecture for which 
                    both availability and security requirements are the most important non-functional 
                    requirements.
            </ol>
            <ol start="6">
                <li>4 Draw diagrams showing a conceptual view and a process view of the architectures of the 
                    following systems:  </p>
                    An automated ticket-issuing system used by passengers at a railway station.  </p>
                    A computer-controlled video conferencing system that allows video, audio, and computer data 
                    to be visible to several participants at the same time.  </p>
                    A robot floor cleaner that is intended to clean relatively clear spaces such as corridors. The
                    cleaner must be able to sense walls and other obstructions. </p>
            </ol>

            <ol start="6">
                <li>5 Explain why you normally use several architectural patterns when designing the architecture 
                    of a large system. Apart from the information about patterns that I have discussed in this 
                    chapter, what additional information might be useful when designing large systems? </p>

                <li>6 Suggest an architecture for a system (such as iTunes) that is used to sell and distribute music
                    <br>
                    on the Internet. What architectural patterns are the basis for this architecture? </p>

                <li>7 Explain how you would use the reference model of CASE environments (available on the 
                    book’s web pages) to compare the IDEs offered by different vendors of a programming 
                    language such as Java. </p>

                <li>8 Using the generic model of a language processing system presented here, design the 
                    architecture of a system that accepts natural language commands and translates these into
                    database queries in a language such as SQL. </p>

                <li>9 Using the basic model of an information system, as presented in Figure 6.16, suggest the 
                    components that might be part of an information system that allows users to view information
                    about flights arriving and departing from a particular airport. </p>

                <li>10 Should there be a separate profession of ‘software architect’ whose role is to work 
                    independently with a customer to design the software system architecture? A separate 
                    software company would then implement the system. What might be the difficulties of 
                    establishing such a profession?
            </ol>

        </article>
    </section>



<footer>
    <section class="references">
        <h2> REFERENCES</h2>
        <article>
           <p> Bass, L., Clements, P. and Kazman, R. (2003). Software Architecture in Practice, 2nd ed. Boston: <br>
            Addison-Wesley. </p>
            Berczuk, S. P. and Appleton, B. (2002). Software Configuration Management Patterns: Effective <br>
            Teamwork, Practical Integration. Boston: Addison-Wesley. </p>
            Booch, G. (2009). ‘Handbook of software architecture’. Web publication. <br>
            http://www.handbookofsoftwarearchitecture.com/. </p>
            Bosch, J. (2000). Design and Use of Software Architectures. Harlow, UK: Addison-Wesley. </p>
            Buschmann, F., Henney, K. and Schmidt, D. C. (2007a). Pattern-oriented Software Architecture <br>
            Volume 4: A Pattern Language for Distributed Computing. New York: John Wiley & Sons. </p>
            Buschmann, F., Henney, K. and Schmidt, D. C. (2007b). Pattern-oriented Software Architecture <br>
            Volume 5: On Patterns and Pattern Languages. New York: John Wiley & Sons. </p>
            Buschmann, F., Meunier, R., Rohnert, H. and Sommerlad, P. (1996). Pattern-oriented Software <br>
            Architecture Volume 1: A System of Patterns. New York: John Wiley & Sons </p>
            Clements, P., Bachmann, F., Bass, L., Garlan, D., Ivers, J., Little, R., Nord, R. and Stafford, J. (2002).
            <br>
            Documenting Software Architectures: Views and Beyond. Boston: Addison-Wesley. </p>
            Coplien, J. H. and Harrison, N. B. (2004). Organizational Patterns of Agile Software Development. <br>
            Englewood Cliffs, NJ: Prentice Hall. </p>
            Gamma, E., Helm, R., Johnson, R. and Vlissides, J. (1995). Design Patterns: Elements of Reusable <br>
            Object-Oriented Software. Reading, Mass.: Addison-Wesley. </p>
            Garlan, D. and Shaw, M. (1993). ‘An introduction to software architecture’. Advances in Software <br>
            Engineering and Knowledge Engineering, 1 1–39. </p>
            Harold, E. R. and Means, W. S. (2002). XML in a Nutshell. Sebastopol. Calif.: O‘Reilly. </p>
            Hofmeister, C., Nord, R. and Soni, D. (2000). Applied Software Architecture. Boston: Addison <br>
            Wesley. </p>
            Hunter, D., Rafter, J., Fawcett, J. and Van Der Vlist, E. (2007). Beginning XML, 4th ed. Indianapolis, <br>
            Ind.: Wrox Press. </p>
            Kircher, M. and Jain, P. (2004). Pattern-Oriented Software Architecture Volume 3: Patterns for <br>
            Resource Management. New York: John Wiley & Sons. </p>
            Krutchen, P. (1995). ‘The 4+1 view model of software architecture’. IEEE Software, 12 (6), 42–50. </p>
            Lange, C. F. J., Chaudron, M. R. V. and Muskens, J. (2006). ‘UML software description and <br>
            architecture description’. IEEE Software, 23 (2), 40–6. </p>
            Lewis, P. M., Bernstein, A. J. and Kifer, M. (2003). Databases and Transaction Processing: An <br>
            Application-oriented Approach. Boston: Addison-Wesley. </p>
            Martin, D. and Sommerville, I. (2004). ‘Patterns of interaction: Linking ethnomethodology and <br>
            design’. ACM Trans. on Computer-Human Interaction, 11 (1), 59–89. </p>
            Nii, H. P. (1986). ‘Blackboard systems, parts 1 and 2’. AI Magazine, 7 (3 and 4), 38–53 and 62–9. </p>
            Schmidt, D., Stal, M., Rohnert, H. and Buschmann, F. (2000). Pattern-Oriented Software <br>
            Architecture Volume 2: Patterns for Concurrent and Networked Objects. New York: John Wiley & <br>
            Sons. <p> </p>
            Shaw, M. and Garlan, D. (1996). Software Architecture: Perspectives on an Emerging Discipline. </p>
            Englewood Cliffs, NJ: Prentice Hall. <br>
            Usability group. (1998). ‘Usability patterns’. Web publication. <br>
            <a
                href="http://www.it.bton.ac.uk/cil/usability/patterns/" class="link1">http://www.it.bton.ac.uk/cil/usability/patterns/</a>.
            </p>


        </article>
    </section>
</footer>

</body>

</html>